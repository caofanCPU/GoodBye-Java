= ㍿ Redis吐槽大会
帝八哥<xyb5to0zcy@gmail.com>
v1.0, 2021-04-01
:toc: right

== Redis灵魂4问
=== ##缓存穿透##
* 穿透(透传, 本来没有你非要查), 就是数据库本来没有这个key的数据, 缓存里肯定也没有,
大量请求就像恶意攻击一样压垮数据库。
* 解决办法是**位数组**或者**布隆过滤器**拦截不存在key请求。
**位数组**就是根据key的hash确定最大值Max, 然后开辟至少Max个bit位的数组,
每个key对数组做取模运算, 存在时该位为1, 不存在时该位为0,
缺点是开辟的数组空间受最大值影响, 比如只有三个key, 1, 2, 100万,
那必须开辟至少100万bit的数组, 99%以上的空间都浪费了。
* 因此出现了**布隆过滤器**, 优化思想是允许一定的误判率, 节省所需要的数组空间。
原理是写缓存时用n个hash函数计算出n个bit位值(即确定n个位的索引及值),
读缓存时同样计算n个bit位, 然后和已有的bit位比对, #全部相同则可能存在, 任意一位不同则一定不存在#。
因为一般单机数据库2000并发还是可以抗住的, 假定允许1%的误判率, 那整个系统能抗住2000*100的并发,
解决问题的效果是很可观的。那么是如何节省数组空间的呢? 答案是对key进行多个hash计算。
* 经过良好设计的hash函数能提供将原始数据打散, 减少碰撞或者碰撞率很少,
多次hash运算后还发生碰撞(也就是不存在的key1和存在key2经过多个hash函数处理后结果相同),
那概率太小了, 理论上用无穷个hash函数可以将碰撞概率降为0,
但是这样计算效率又大打折扣, 所以采取折中的办法, 用户根据允许的误判率来决定用多少个hash函数处理。
* 布隆过滤器也有缺点:
** 是基于JVM的, 重启失效, 不具备分布式缓存特点, 可以改为**Redis的bitmap**
** 不能删除, 需要定期更换

=== ##缓存击穿##
* 热点key刚好过期时刻, 多个线程请求数据, 导致数据库并发压力大, 解决办法是查数据库时加锁,
类似于保证只加载一次数据的方式:
** 先查缓存没有, 那就加锁(synchronized或者lock), 再查缓存还是没有, 读数据库, 写缓存, 再返回。
这样的好处是, 让并发请求数据库阻挡在并发请求应用服务
** 这些并发请求因为加锁而排队, 抑制了并发。还有就是对于热点key可以用异步线程检测,
发现快过期时从数据库加载, 保证不过期。
** 之所以不使用分布式锁是因为应用服务部署的机器台数始终是有限的, 一个应用服务部署2000台机器,
并且正好2000个请求都是初始加载数据, 还同时到达数据库, 这个概率...
** 即便有, 用主从架构拓展数据库, 增加并发读能力

=== ##缓存雪崩##
* 大量热点key同时过期或者redis挂了, 导致成千上万请求压垮数据库
* 大量热点key同时过期的解决办法: 热点key过期时间错开加随机时间
* redis挂了的解决办法: 使用redis集群架构解决redis宕机问题,
* 稳定系统应该在业务应用上采用服务降级、熔断, 将大量请求快速返回: *服务器繁忙, 请稍后重试*

=== ##缓存数据不一致##
* 主要**发生在更新数据场景**下, 如果先更新缓存再更新db, 应为db可能会回滚,
这种方式很可能导致数据不一致, 基本不用。 先更新DB, 事务完成后再更新缓存,
此时数据库DB是新数据, 如果缓存更新失败, 那么缓存还是以前的就缓存,
因而也会有数据不一致的可能。具体分两种情况:
** 单线程, 更新DB前先删除旧缓存, 再更新DB, 这样不论DB更新成功或失败, 读取时都是到数据库拉数据,
数据是一致的。 这里可能有个疑问点, 缓存都删除了, 不用缓存也是该效果啊!
这是因为**缓存本来就是用于读多写少的场景**。
** 多线程情况下, 上述单线程先删缓存再更新DB, 仍旧会出现数据不一致的情况, 举例:
*** A先删除旧缓存
*** B查询缓存发现为空, 去数据库查到旧数据写入缓存
*** A更新DB
*** 这样DB是新数据, 缓存是旧数据, 解决办法是**延时双删**, *就是更新DB前删除缓存, 更新DB后再删缓存*
** 延时双删是相对较好的方式, 大公司更多倾向于引入**消息事务**完成

== Redis数据结构及应用
=== string
* 字符串, 最大支持512M的值, 但是生产上禁止超过1M的数据, 因为会存在较大的网络IO消耗

=== hash
* 存储对象, 多个字段信息放一起

=== list
* 双端队列

=== set

=== zset
* 有序集合, 带权重的分数字段, 应用于胖排行榜

=== bitmap
* 位图, 应用于用户点赞、用户签到(每个用户一个位图)统计活跃用户, 在一个bitmap中, 用户id做索引

=== Pipeline
* Pipeline是客户端行为, 对于服务端来说没有任何感知
* Pipeline重大的优点就是在客户端与服务端的一个连接中执行多个redis命令, 就是复用连接批量执行, 提升效率
* pipeline缺点就是无法保证原子性, 因为底层原理是客户端将要执行的命令放入与服务端连接的socket缓冲区,
当缓冲区满的时候例如4KB, 就发送给服务端了, 那这就'坑爹了', 两条相关的命令就被拆散了, 到服务端是分两次执行的。

=== Redis事务
* 就是一组特殊命令, 先告诉服务端我要执行的是事务, 服务端会收集多个执行命令,
收到事务结束命令时再批量执行这些命令。
* redis的事务依然无法保证原子性, 如果要保证原子性, 命令中封装luna脚本

== Redis高端话题
=== Redis主从原理
- 1.从库启动后向主库发送同步命令, 主库进行RDB(也叫快照, bigsave), fork跟自己一样的一个子进程,
把内存数据保存在dump.rdb文件中
- 2.然后主库向从库发送rdb文件, 在fork期间以及发送文件期间, 主库会把执行的写命令缓存起来, 之后一起发送给从库
- 3.从库执行dump.rdb和写命令, 就会得到和主库一样的数据
- 优缺点:
* 优点:
** 读写分离, 写主库, 增加了读的并发
** 主库挂了从库还有数据
* 缺点:
** 主从同步延时, 同步期间从库读取的可能是旧数据
** 单点故障, 主库挂了需要人工参与解决
** 容量问题是很大的瓶颈

=== Redis哨兵原理
- 1.在主从架构上增加奇数个节点, 不存储数据, 叫做哨兵节点, 只负责监控、master(主库)选举作用。
- 2.哨兵节点与master、slave节点保持心跳通信, 当哨兵发现master一段时间无心跳回应时,
首先将心跳频率从默认10s问一次, 提高到1s问一次
- 3.如果master还是无反应, 那么该哨兵节点就认为master**主观下线**, 然后哨兵之间相互交换认定结果,
如果超过半数的哨兵节点都认为master主观下线, 那么哨兵节点就认定该master节点**客观下线**(挂了)
- 4.开启选举, 从slave中选举出一个作为master, 选举原则是:
优先选择slave-priority的节点, slave-priority相同, 则选择同步主库数据偏移量最大的, 最大的数据最完整,
偏移量相同, 那就选择slave-id越小的
- 优缺点
* 优点: 自动故障转移, master挂了在一定时间内能恢复
* 缺点:
** 选举过程中无法对外提供服务, 不具备高可用
** 并且主从切换过程中会丢数据
** 由于只有一个master, 只能单机写, 无法水平扩容

=== Redis集群原理
- 由主从架构演变而来, 将数据进行分片, 分散存入多个主从节点区, 每个主从区保证奇数个节点,
且算上master节点最少3个, 并且整个集群至少需要3个主节点并且也得保证奇数个。
执行写数据时, 首选根据key计算hash槽, 确定主节点, 主节点写入数据后,
会让从节点同步数据, 并且超过半数(算上主节点自身)写入成功才成功, 否则禁止master写入。
- redis集群规定奇数个节点的原因:
* 主节点至少是3个, 首先主节点肯定得大于1个, 否则就是主从架构了,
其次当发生故障转移时需要集群讨论做决定, 那么2个主节点挂掉一个后只剩1个未超过集群一半, 无法选举, 集群就挂了。 所以至少3个
* 在单个主从区, 主要是写数据时需要确认半数以上节点能写入成功, 至少2个
* 所以, 一个Redis集群最少3*2=6个节点
* 总结: 主节点数目是为了保证故障转移, 主从节点数据是为了保证写入后数据的最终一致性
- 优缺点:
* 优点:
** 故障自动转移, 主节点挂了后从节点会接管
** 可以横向拓展
* 缺点:
** 不支持mget, mset等批量的原子性命令, 因为不同的key会划分到不同的槽中甚至是不同的机器中,
解决办法是用HashTag, key前缀用来算插槽, key的后面算分片hash
** 集群至少6台机器, 增加成本
** #slave只能充当冷备, 也就是slave节点并不提供读取服务, 集群读写都在master节点上#

== Redis杂论
- 线程模型: 单线程没有多线程的上下文切换, 内存操作速度很快, IO多路复用+时间循环模型,
单线程操作就很快, 单机QPS可达到10w
- 内存淘汰策略:
* 惰性删除+定期删除
* **LRU(算法实现)**最近最少使用
- 高并发场景可考虑缓存预热, 异步线程刷新数据
- 参考WAL思想, 缓存也可以追加只记录操作, 交由业务代码提取最新数据

== 参考资料
[bibliography]


